<script src="../bower_components/underscore/underscore-min.js"></script>
<script src="../bower_components/randomcolor/randomColor.js"></script>
<script src="../bower_components/d3/d3.min.js"></script>
<script>
	window.Morgana = window.Morgana || {
    fetchArticles: (limit) => {
      return fetch('/api/articles', {mode: 'cors'})
      .then((resp) => { return resp.json(); })
    },
  	generateGraph: (N, E) => {
  		var g = {
  			nodes: [],
  			edges: []
  		}
  		g.nodes = _.map(_.range(N), (i) => {
  			return {
  				id: i,
                  label: 'Node ' + i,
                  x: Math.random() * 100,
                  y: Math.random() * 100,
                  size: Math.random() * 10,
                  color: '#666'
  			}
  		});
  		g.edges = _.map(_.range(E), (i) => {
  			return {
  				id: i,
                  source: (Math.random() * N | 0),
                  target: (Math.random() * N | 0),
                  size: Math.random(),
                  color: '#ccc'
  			}
  		});
  		return g;
  	},
    processNodeList: (nodes) => {
      var minSize = 1;
      var maxSize = 5;
      return _.map(nodes, (node) => {
        node.x = Math.random() * 100;
        node.y = Math.random() * 100;
        node.color = "#000";
        node.size = Math.random() * (maxSize - minSize) + minSize;
        return node;
      })
    },
  	applyGraphStyles: function(sigmaInstance) {

  	},
  	applyGraphInteractions: function(sigmaInstance) {
  		sigmaInstance.bind('doubleClickNode', function(e) {
  			console.log(e);
  		});
  		sigmaInstance.bind('hovers', function(e) {
  			var adjacentNodes = [];

  	        if (!e.data.enter.nodes.length) return;

  	        // Get deduped, flattened list of all neighbours of all nodes in hover
  	        adjacentNodes = _.uniq(_.flatten(_.map(e.data.enter.nodes, (node) => {
  	        	return this.graph.adjacentNodes(node.id)
  	        })));

  	            // Render halo:
  	        this.renderers[0].halo({
  	        nodes: adjacentNodes
  	        });
  		}.bind(sigmaInstance))

  		sigma.plugins.tooltips(sigmaInstance, sigmaInstance.renderers[0], {
  			node: [{
  	            show: 'clickNode',
  	            renderer: function(node) {
  	            	console.log(node);
  	            }
              }]
  		});
  	},
  	applyForceLink: function(sigmaInstance) {
  		var fa = sigma.layouts.configForceLink(sigmaInstance, {
  			worker: true,
  			autoStop: true,
  			background: true,
  			scaleRatio: 10,
  			gravity: 5,
  			easing: 'cubicInOut'
  		});
  		// Bind the events:
  		fa.bind('start stop', function(e) {
  			console.log(e.type);
  		});
  		// Start the ForceLink algorithm:
  		sigma.layouts.startForceLink();
  		console.log("ForceLink started");
  		return fa;
  	},
  	findNeighbourhoodOfAuthor: function(graph,author_st_name) {
  		return graph;
  	},
		sunburst_dev: {

		},
    sunburst: {
			getAncestors: function(node) {
				var path = [];
				var current = node;
				while (current.parent) {
					path.unshift(current);
					current = current.parent;
				}
				return path;
			},
			fetchNetwork: function(d) {
				console.log(d);
				console.log(Morgana.sunburst.getAncestors(d))
				// Use the standard CustomEventAPI, not Polymer sugaring
				document.querySelector('morgana-app').dispatchEvent(new CustomEvent('morgana-fetch-network',
					{detail: {ancestors: Morgana.sunburst.getAncestors(d)}, bubbles: true}))
			},
      generate: function() {
				console.log(b);
        var totalSize = 0;
        var width = 640;
        var height = 480;
        var radius = Math.min(width, height) / 2;
        var b = {
          w: 150, h: 30, s: 3, t: 10
        };
        var vis = d3.select('.sunburst-container').append("svg:svg")
            .attr("width", width)
            .attr("height", height)
            .append("svg:g")
            .attr("id", "container")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        var partition = d3.layout.partition()
            .size([2 * Math.PI, radius * radius])
            .value(function(d) { return d.size; });

        var arc = d3.svg.arc()
            .startAngle(function(d) { return d.x; })
            .endAngle(function(d) { return d.x + d.dx; })
            .innerRadius(function(d) { return Math.sqrt(d.y); })
            .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });

        fetch('/api/sunburst', {mode: 'cors'})
        .then( (resp) => { return resp.json()})
        .then( (tree) => {
          createVisualization(tree)
        })

				function fetchNetwork(d) {
					console.log(d);
					console.log(Morgana.sunburst.getAncestors(d))
					// Use the standard CustomEventAPI, not Polymer sugaring
					this.dispatchEvent(new CustomEvent('morgana-fetch-network',
						{detail: {ancestors: Morgana.sunburst.getAncestors(d)}, bubbles: true}))
				}
        // Main function to draw and set up the visualization, once we have the data.
        function createVisualization(json) {
					function computeStringWidth(string, font) {
						var container = document.createElement('span');
						container.innerHTML = string;
						container.style.fontFamily = font;
						var width = container.clientWidth;
						return width;
					}
          // Basic setup of page elements.
          initializeBreadcrumbTrail();

          // Bounding circle underneath the sunburst, to make it easier to detect
          // when the mouse leaves the parent g.
          vis.append("svg:circle")
              .attr("r", radius)
              .style("opacity", 0);

          // For efficiency, filter nodes to keep only those large enough to see.
          var nodes = partition.nodes(json)
              .filter(function(d) {
              return (d.dx > 0.005); // 0.005 radians = 0.29 degrees
              });

					this.colors = {"root": "#fff"}
					nodes.map(function(node) {
						this.colors[node.name] = randomColor({"luminosity": "bright", hue: "blue"});
						node['string_width'] = computeStringWidth(node.name, 'Open-Sans');
					})

          var path = vis.data([json]).selectAll("path")
              .data(nodes)
              .enter().append("svg:path")
              .attr("display", function(d) { return d.depth ? null : "none"; })
              .attr("d", arc)
							.attr('name', function(d) { return d.name })
              .attr("fill-rule", "evenodd")
              .style("fill", function(d) { return this.colors[d.name]; }.bind(this))
              .style("opacity", 1)
              .on("mouseover", mouseover);

          // Add the mouseleave handler to the bounding circle.
          d3.select("#container").on("mouseleave", mouseleave);
					// d3.selectAll("path")
					// .on("click", fetchNetwork);
          // Get total size of the tree = value of root node from partition.
          totalSize = path.node().__data__.value;
         };

        // Fade all but the current sequence, and show it in the breadcrumb trail.
        function mouseover(d) {

          var percentage = (100 * d.value / totalSize).toPrecision(3);
					var val = d.value;
          var percentageString = `${percentage}%`;
          if (percentage < 0.1) {
            percentageString = "< 0.1%";
          }

          d3.select("#percentage")
              .html(percentageString+`<br />${val}/${totalSize}`);

          // d3.select("#explanation")
          //     .style("visibility", "");

          var sequenceArray = Morgana.sunburst.getAncestors(d);
          updateBreadcrumbs(sequenceArray, percentageString);

          // Fade all the segments.
          d3.selectAll("path")
              .style("opacity", 0.3);

          // Then highlight only those that are an ancestor of the current segment.
          vis.selectAll("path")
              .filter(function(node) {
                        return (sequenceArray.indexOf(node) >= 0);
                      })
              .style("opacity", 1);
        }

        // Restore everything to full opacity when moving off the visualization.
        function mouseleave(d) {

          // Hide the breadcrumb trail
          d3.select("#trail")
              .style("visibility", "hidden");

          // Deactivate all segments during transition.
          d3.selectAll("path").on("mouseover", null);

          // Transition each segment to full opacity and then reactivate it.
          d3.selectAll("path")
              .transition()
              .duration(1000)
              .style("opacity", 1)
              .each("end", function() {
                      d3.select(this).on("mouseover", mouseover);
                      d3.select(this).on("click", Morgana.sunburst.navigate);
                    });

          // d3.select("#explanation")
          //     .style("visibility", "hidden");
        }

        // Given a node in a partition layout, return an array of all of its ancestor
        // nodes, highest first, but excluding the root.
        function getAncestors(node) {
          var path = [];
          var current = node;
          while (current.parent) {
            path.unshift(current);
            current = current.parent;
          }
          return path;
        }

        function initializeBreadcrumbTrail() {
          // Add the svg area.
          var trail = d3.select("#sequence").append("svg:svg")
              .attr("width", width)
              .attr("height", 50)
              .attr("id", "trail");
          // Add the label at the end, for the percentage.
          trail.append("svg:text")
            .attr("id", "endlabel")
            .style("fill", "#000");
        }

        // Generate a string that describes the points of a breadcrumb polygon.
        function breadcrumbPoints(d, i) {
          var points = [];
          points.push("0,0");
          points.push(b.w + ",0");
          points.push(b.w + b.t + "," + (b.h / 2));
          points.push(b.w + "," + b.h);
          points.push("0," + b.h);
          if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
            points.push(b.t + "," + (b.h / 2));
          }
          return points.join(" ");
        }

        // Update the breadcrumb trail to show the current sequence and percentage.
        function updateBreadcrumbs(nodeArray, percentageString) {

          // Data join; key function combines name and depth (= position in sequence).
          var g = d3.select("#trail")
              .selectAll("g")
              .data(nodeArray, function(d) { return d.name + d.depth; });

          // Add breadcrumb and label for entering nodes.
          var entering = g.enter().append("svg:g");

          entering.append("svg:polygon")
              .attr("points", breadcrumbPoints)
              .style("fill", function(d) { return this.colors[d.name]; }.bind(this));

          entering.append("svg:text")
              .attr("x", (b.w + b.t) / 2)
              .attr("y", b.h / 2)
              .attr("dy", "0.35em")
              .attr("text-anchor", "middle")
              .text(function(d) { return d.name; });

          // Set position for entering and updating nodes.
          g.attr("transform", function(d, i) {
            return "translate(" + i * (b.w + b.s) + ", 0)";
          });

          // Remove exiting nodes.
          g.exit().remove();

          // Now move and update the percentage at the end.
          d3.select("#trail").select("#endlabel")
              .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
              .attr("y", b.h / 2)
              .attr("dy", "0.35em")
              .attr("text-anchor", "middle")
              .text(percentageString);

          // Make the breadcrumb trail visible, if it's hidden.
          d3.select("#trail")
              .style("visibility", "");

        }
      },
			navigate: function(d) {
				nav_choice = document.querySelector('#navigation-direction').checked;
				if(nav_choice) {
					Morgana.grid.displayFromSunburst(Morgana.sunburst.getAncestors(d));
				} else {
					console.log("Fetching related network");
					Morgana.sunburst.fetchNetwork(d);
				}
			}
    },
		network: {
			community: function(sigma_inst) {
				var louvainInstance = sigma.plugins.louvain(sigma_inst.graph, {
				  setter: function(communityId) { this.community = communityId; }
				});
			},
			display: function(network_object) {
				var random_colors = {}
				network_object.nodes.map((node) => {
					node.x = Math.random() * 100;
					node.y = Math.random() * 100;
					node.color = randomColor();
					node.size = Math.pow(10, node.size + 3)
				})
				this.s.graph.clear();
				this.s.graph.read(network_object);
				setTimeout(function() {
					this.s.refresh(); this.s.refresh();
					Morgana.network.community(this.s)
					this.s.graph.nodes().map((node) => {
						if (!(node.community in random_colors)) {
							random_colors[node.community] = randomColor({luminosity: "bright", hue: "blue"});
						}
						node.color = random_colors[node.community];
					})
					var fa = Morgana.applyForceLink(this.s)
				}.bind(this), 500);

			}
		},
		grid: {
			displayFromGraph: function(nodes) {
				var filters = {}
				nodes.map((node) => {
					fields[node._value] = "*";
				})
				fetch('/api/patients', {data: filters})
				.then(resp => resp.json())
				.then(function(patients) {
					this.dispatchEvent(new CustomEvent('morgana-display-patients', {detail: patients, bubbles: true}))
				}.bind(this))
			},
			displayFromSunburst: function(ancestors) {
				filters = {};
				ancestors.map( (ancestor) => {
					// use both varname and value
					filters[ancestor._variable] = ancestor._value
				})
				document.querySelector('morgana-app').dispatchEvent(new CustomEvent('morgana-fetch-patient-grid', {detail: ancestors, bubbles: true}))
			}
		}
  }
</script>
